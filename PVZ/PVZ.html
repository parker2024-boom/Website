<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>PVZ Multi Plant/Zombie Demo</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      background: black;
    }
    canvas {
      display: block;
      cursor: crosshair;
      background: url("images/background.jpg") no-repeat center center;
      background-size: cover;
      aspect-ratio: 16 / 9;
      height: 100vh;
      max-width: 100vw;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <audio id="bgm" src="sounds/植物大战僵尸背景音乐.mp3" loop></audio>
  <audio id="bite" src="sounds/僵尸咀嚼植物音效.mp3"></audio>
  <audio id="zombieDie" src="sounds/僵尸死亡音效.mp3"></audio>
  <audio id="winSound" src="sounds/植物大战僵尸胜利音效.mp3"></audio>
  <audio id="loseSound" src="sounds/植物大战僵尸游戏失败音效.mp3"></audio>
  <audio id="waveSound" src="sounds/植物大战僵尸游戏一大波僵尸袭来音效.mp3"></audio>
  <audio id="peaHit" src="sounds/豌豆击中僵尸.mp3"></audio>
  <audio id="peaShoot" src="sounds/豌豆射手射击.mp3"></audio>

  <script>

    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    let laneHeight = 0;
    const lanes = [];

    let bgmStarted = false;

    canvas.addEventListener('click', () => {
      if (!bgmStarted) {
        const bgm = document.getElementById("bgm");
        bgm.volume = 0.8;  // 可调节音量
        bgm.play().catch(e => console.log("背景音乐被拦截:", e));
        bgmStarted = true;
      }
    });


    function resizeCanvas() {
      const height = window.innerHeight;
      const width = height * (16 / 9);
      canvas.width = width;
      canvas.height = height;

      laneHeight = canvas.height / 6;
      lanes.length = 0;
      for (let i = 1; i <= 5; i++) lanes.push(i * laneHeight);

      // 更新植物位置和尺寸
      plants.forEach(p => {
        p.width = canvas.width * 0.0825;
        p.height = canvas.height * 0.135;
        p.x = p.relX * canvas.width - p.width / 2;
        p.y = p.relY * canvas.height - p.height / 2;
      });

      // 更新僵尸位置和尺寸
      zombies.forEach(z => {
        z.width = canvas.width * 0.0875;
        z.height = canvas.height * 0.225;
        z.x = z.relX * canvas.width - z.width / 2;
        z.y = z.relY * canvas.height - z.height / 2;
      });
    }

    const images = {
      peashooter: new Image(),
      sunflower: new Image(),
      zombie: new Image(),
      conehead: new Image(),
      bullet: new Image(),
      reward: new Image()
    };
    images.peashooter.src = "images/peashooter.png";
    images.sunflower.src = "images/sunflower.png";
    images.zombie.src = "images/zombie.png";
    images.conehead.src = "images/conehead.png";
    images.bullet.src = "images/bullet.png";
    images.reward.src = "images/reward.png";

    const plants = [];
    const zombies = [];
    const bullets = [];

    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    let spawnCount = 0;
    const maxSpawns = 5;
    let zombiesPerWave = 2;

    let selectedPlant = 'peashooter';

    function canPlacePlant(x) {
      const gridWidth = canvas.width / 10;
      return x > gridWidth && x < canvas.width - gridWidth * 2;
    }

    canvas.addEventListener('click', e => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const snappedY = lanes.reduce((prev, curr) => Math.abs(curr - y) < Math.abs(prev - y) ? curr : prev);

      const pw = canvas.width * 0.0825;
      const ph = canvas.height * 0.135;

      if (canPlacePlant(x)) {
        plants.push({
          type: selectedPlant,
          relX: x / canvas.width,
          relY: snappedY / canvas.height,
          x: x - pw / 2,
          y: snappedY - ph / 2,
          width: pw,
          height: ph,
          hp: 5 //生命
        });
      }
    });

    function drawPlants() {
      plants.forEach(p => ctx.drawImage(images[p.type], p.x, p.y, p.width, p.height));
    }

    function drawZombies() {
      zombies.forEach(z => ctx.drawImage(images[z.type], z.x, z.y, z.width, z.height));
    }

    function drawBullets() {
      bullets.forEach(b => {
        const image = images.bullet;
        const aspectRatio = image.width / image.height || 1;
        const plantWidth = canvas.width * 0.1;
        const bulletHeight = plantWidth / 5;
        const bulletWidth = bulletHeight * aspectRatio;

        b.width = bulletWidth;
        b.height = bulletHeight;

        const nearestLaneCenter = lanes.reduce((prev, curr) =>
          Math.abs(curr - b.y) < Math.abs(prev - b.y) ? curr : prev
        );

        const adjustedY = nearestLaneCenter - laneHeight / 2 + laneHeight * 0.4 - bulletHeight / 2;
        ctx.drawImage(image, b.x, adjustedY, bulletWidth, bulletHeight);
      });
    }

    function updateGame() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawPlants();
      drawZombies();
      drawBullets();

      bullets.forEach((b, i) => {
        b.x += b.speed;
        zombies.forEach(z => {
          if (b.x + b.width > z.x && b.x < z.x + z.width && b.y > z.y && b.y < z.y + z.height) {
            document.getElementById("peaHit").play(); // 播放击中音效
            z.hp--;
            bullets.splice(i, 1);
          }
        });
      });

      let escaped = 0;
      for (let i = zombies.length - 1; i >= 0; i--) {
        const z = zombies[i];

        // 检查是否碰到植物
        let isEating = false;
        let eatenIndex = -1;

        for (let j = 0; j < plants.length; j++) {
          const p = plants[j];
          const inSameLane = Math.abs(z.y - p.y) < laneHeight / 2;
          const overlapping = z.x < p.x + p.width && z.x + z.width > p.x;

          if (inSameLane && overlapping) {
            isEating = true;

            // 播放咀嚼音效
            const biteSound = document.getElementById("bite");
            if (biteSound.paused) {
              biteSound.currentTime = 0;
              biteSound.play();
            }

            p.hp -= 0.03;
            if (p.hp <= 0) {
              eatenIndex = j;
            }
            break;
          }
        }

        if (eatenIndex >= 0) {
          plants.splice(eatenIndex, 1);
        }

        if (!isEating) {
          z.x -= z.speed;
        }

        z.relX = (z.x + z.width / 2) / canvas.width; // 保持相对位置

        if (z.hp <= 0) {
          zombieDie.volume = 0.2
          document.getElementById("zombieDie").play();
          zombies.splice(i, 1);
        } else if (z.x < canvas.width * 0.05) {
          escaped++;
        }
      }

      if (escaped >= 3) {
        document.getElementById("loseSound").play();
        ctx.fillStyle = "red";
        ctx.font = "40px Arial";
        ctx.textAlign = "center";
        ctx.fillText("你输了！", canvas.width / 2, canvas.height / 2);
        return;
      }

      if (zombies.length === 0 && spawnCount === maxSpawns) {
        document.getElementById("winSound").play();

        ctx.fillStyle = "black";
        ctx.font = "40px Arial";
        ctx.textAlign = "center";
        ctx.fillText("你赢了！", canvas.width / 2, canvas.height / 5 * 2);

        // ✅ 绘制 reward.png 图片
        const rewardImg = images.reward;
        const imgWidth = canvas.width * 0.25;
        const imgHeight = canvas.height * 0.25;
        const imgX = (canvas.width - imgWidth) / 2;
        const imgY = (canvas.height - imgHeight) / 2 + 50;

        ctx.drawImage(rewardImg, imgX, imgY, imgWidth, imgHeight);
        return;
      }

      requestAnimationFrame(updateGame);
    }

    setInterval(() => {
      plants.forEach(p => {
        if (p.type === 'peashooter') {
          const zombiesInLane = zombies.some(z => Math.abs(z.y - p.y) < p.height / 2);
          if (zombiesInLane) {
            document.getElementById("peaShoot").play();
            bullets.push({
              x: p.x + p.width - 10,
              y: p.y + p.height / 2 - 8,
              width: 30,
              height: 15,
              speed: 4
            });
          }
        }
      });
    }, 2000);

    function spawnZombieWave() {
      document.getElementById("waveSound").play();

      for (let i = 0; i < zombiesPerWave; i++) {
        const laneY = lanes[Math.floor(Math.random() * lanes.length)];
        const type = Math.random() < 0.5 ? 'zombie' : 'conehead';
        const hp = type === 'zombie' ? 5 : 8;

        const baseSpeed = type === 'zombie' ? 0.8 : 0.7;
        const speed = baseSpeed + spawnCount * 0.05;

        const zw = canvas.width * 0.0875;
        const zh = canvas.height * 0.225;
        const relX = (canvas.width + i * 60 + zw / 2) / canvas.width;
        const relY = laneY / canvas.height;

        zombies.push({
          type,
          relX,
          relY,
          x: relX * canvas.width - zw / 2,
          y: relY * canvas.height - zh / 2,
          width: zw,
          height: zh,
          hp,
          speed
        });
      }
      spawnCount++;
      zombiesPerWave += 2;
    }

    const waveInterval = setInterval(() => {
      if (spawnCount < maxSpawns) {
        spawnZombieWave();
      } else {
        clearInterval(waveInterval);
      }
    }, 10000);

    let loaded = 0;
    const total = Object.keys(images).length;
    for (let key in images) {
      images[key].onload = () => {
        loaded++;
        if (loaded === total) {
          spawnZombieWave();
          updateGame();
        }

      };
    }
  </script>
</body>
</html>
